#!/usr/bin/perl -w
use strict;
use FindBin;

BEGIN {
	my $local = "$FindBin::RealBin/$FindBin::RealScript.local";
	require $local if -f $local;
}

use Cwd qw(abs_path);
use DateTime;
use File::Basename;
use File::Path;
use Getopt::Long;
use IO::Handle;
use POSIX;

sub parse_args {
	my $opt = {};
	GetOptions $opt, qw(
		directory=s path=s
		gmt mtime
		force interactive verbose
		help
	) or die $!;

	if ($opt->{help}) {
		my $cmd = basename($0);

		print <<END;
Usage: $cmd [OPTIONS] [FILES..]

Move the specified files (or files in the current directory if omitted) to an
archive directory, classifying the files by the date/time.

Options:
  -d ARCHIVE_DIR, -directory ARCHIVE_DIR
    Specify archive directory. Default = ./archives

  -p DATETIME, -path DATETIME
    Specify date/time format. Default = \%Y/\%m/\%d

  -g, -gmt
    Use GMT intead of local time.

  -f, -force
    Skip the confirmation step at the beginning.

  -i, -interactive
    Confirm each file to move interactively.

  -v, -verbose
    Print each moved file.

  -h, -help
    Display help.
END

		exit 1;
	}

	return wantarray ? ($opt, @ARGV) : $opt;
}

sub should_move {
	my ($file, $dir) = @_;
	return 0 if basename($file) =~ /^\.\.?$/;
	return abs_path($file) !~ m{^$dir(/|$)};
}

sub make_time {
	my ($opt, $year, $month, $day, $hour, $minute, $second) = @_;
	
	if ($opt->{gmt}) {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second, time_zone => 'GMT')->epoch;
	} else {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second)->epoch;
	}
}

sub get_time {
	my ($opt, $file) = @_;
	my $base = basename($file);

	if ($base =~ /\b(\d{4})(\d{2})(\d{2})[\-\._]?(\d{2})(\d{2})(\d{2})\b/) {
		return make_time($opt, $1, $2, $3, $4, $5, $6);
	} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})\b/) {
		return make_time($opt, $1, $2, $3, $4, $5, $6);
	} elsif ($base =~ /\b(\d{4})(\d{2})(\d{2})\b/) {
		return make_time($opt, $1, $2, $3, 0, 0, 0);
	} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})\b/) {
		return make_time($opt, $1, $2, $3, 0, 0, 0);
	}

	return ((stat $file)[9]);
}

sub move_file {
	my ($opt, $file, $time, $dir, $absdir, $path) = @_;

	my $dst = ($opt->{gmt} ?
			strftime($path, gmtime $time) :
			strftime($path, localtime $time));

	if ($opt->{interactive}) {
		print "$dst: $file: Archive? [y/N] ";
		STDOUT->flush;
		return if <STDIN> !~ /^y/i;
	}

	mkpath "$absdir/$dst" if !-d "$absdir/$dst";
	print "mv $file $dir/$dst\n" if $opt->{verbose};
	rename $file, "$absdir/$dst/".basename($file);
}

sub main {
	my ($opt, @files) = parse_args();

	# Configure input
	my $dir = defined $opt->{directory} ? $opt->{directory} : 'archives';
	my $absdir = abs_path($dir);

	my $path = defined $opt->{path} ? $opt->{path} : '%Y/%m/%d';

	@files = <./*> if @files == 0; # do not include '.*' unless dotglob is on

	# Make plan
	my $plan = {};

	for my $file (@files) {
		if (should_move($file, $absdir)) {
			$plan->{$file} = get_time($opt, $file);
		}
	}

	# Confirm
	my $num_files = scalar(keys %$plan);

	if ($num_files == 0) {
		print "No files to move\n";
		exit 1;
	}

	unless ($opt->{force}) {
		print "Destination: $dir/$path\n";
		print "(Directory will be created)\n" unless -d $dir;
		print "Number of files to move: $num_files\n";
		print "\n";
		print "Proceed? [y/N] ";
		STDOUT->flush;

		if (<STDIN> !~ /^y/i) {
			print "Canceled\n";
			exit 1;
		}
	}

	# Execute
	mkpath $dir if !-d $dir;

	for my $file (@files) {
		if (exists $plan->{$file}) {
			move_file($opt, $file, $plan->{$file}, $dir, $absdir, $path);
		}
	}
}

main();
