#!/usr/bin/env perl
use strict;
use FindBin;

BEGIN {
	eval {require "$FindBin::Script.local"}
}

use Cwd qw(abs_path);
use DateTime;
use File::Basename;
use File::Path;
use Getopt::Long;
use POSIX;

sub parse_args {
	my $opt = {};
	GetOptions $opt, qw(directory=s path=s gmt mtime verbose help) or die $!;

	if ($opt->{help}) {
		my $cmd = basename($0);

		print <<END;
Usage: $cmd [OPTIONS] [FILES..]

Move the specified files (or files in the current directory if omitted) to an
archive directory, classifying the files by the date/time.

Options:
  -directory ARCHIVE_DIRECTORY
    Specify ARCHIVE_DIRECTORY. Default = ./archives

  -path DATETIME_FORMAT
    Specify date/time format. Default = \%Y/\%m/\%d

  -gmt
    Use GMT intead of local time.

  -verbose
    Print each moved file.

  -help
    Display help.
END

		exit 1;
	}

	return wantarray ? ($opt, @ARGV) : $opt;
}

sub should_move {
	my ($file, $dir) = @_;
	return 0 if basename($file) =~ /^\.\.?$/;
	return abs_path($file) !~ m{^$dir(/|$)};
}

sub make_time {
	my ($opt, $year, $month, $day, $hour, $minute, $second) = @_;
	
	if ($opt->{gmt}) {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second, time_zone => 'GMT')->epoch;
	} else {
		return DateTime->new(year => $year, month => $month, day => $day,
			hour => $hour, minute => $minute, second => $second)->epoch;
	}
}

sub get_time {
	my ($opt, $file) = @_;
	my $base = basename($file);

	if ($base =~ /\b(\d{4})(\d{2})(\d{2})[\-\._]?(\d{2})(\d{2})(\d{2})\b/) {
		return make_time($opt, $1, $2, $3, $4, $5, $6);
	} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})[\-\._](\d{2})\b/) {
		return make_time($opt, $1, $2, $3, $4, $5, $6);
	} elsif ($base =~ /\b(\d{4})(\d{2})(\d{2})\b/) {
		return make_time($opt, $1, $2, $3, 0, 0, 0);
	} elsif ($base =~ /\b(\d{4})[\-\._](\d{2})[\-\._](\d{2})\b/) {
		return make_time($opt, $1, $2, $3, 0, 0, 0);
	}

	return ((stat $file)[9]);
}

sub move_file {
	my ($opt, $file, $time, $dir, $absdir, $path) = @_;

	my $dst = ($opt->{gmt} ?
			strftime($path, gmtime $time) :
			strftime($path, localtime $time));

	mkpath "$absdir/$dst" if !-d "$absdir/$dst";
	print "mv $file $dir/$dst\n" if $opt->{verbose};
	rename $file, "$absdir/$dst/".basename($file);
}

sub main {
	my ($opt, @files) = parse_args();

	# Configure input
	my $dir = defined $opt->{directory} ? $opt->{directory} : 'archives';
	my $absdir = abs_path($dir);

	my $path = defined $opt->{path} ? $opt->{path} : '%Y/%m/%d';

	@files = <./*> if @files == 0; # do not include '.*' unless dotglob is on

	# Make plan
	my $plan = {};

	for my $file (@files) {
		if (should_move($file, $absdir)) {
			$plan->{$file} = get_time($opt, $file);
		}
	}

	# Execute
	mkpath $dir if !-d $dir;

	for my $file (@files) {
		if (exists $plan->{$file}) {
			move_file($opt, $file, $plan->{$file}, $dir, $absdir, $path);
		}
	}
}

main();
